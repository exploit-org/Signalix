package org.exploit.signalix.objects.proxy;

import net.bytebuddy.implementation.bind.annotation.*;
import org.exploit.signalix.manager.EventScope;
import org.exploit.signalix.objects.trigger.EventTrigger;
import org.exploit.signalix.objects.trigger.OnExceptionTrigger;

import java.lang.reflect.Method;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;

public class ProxyInterceptor {
    @RuntimeType
    public static Object intercept(
            @Origin Method method,
            @AllArguments Object[] args,
            @SuperCall Callable<Object> zuper,
            @FieldValue("___target") Object target,
            @FieldValue("___methodTriggers") Map<Method, List<EventTrigger>> methodTriggers,
            @FieldValue("___eventScope") EventScope eventScope,
            @FieldValue("___proxy") Object proxy
    ) throws Exception {
        Object returnValue = null;
        Exception exception = null;
        try {
            returnValue = zuper.call();
        } catch (Exception e) {
            exception = e;
        }

        List<EventTrigger> triggers = methodTriggers.get(method);
        if (triggers != null) {
            if (exception != null) {
                for (EventTrigger trigger : triggers) {
                    if (trigger instanceof OnExceptionTrigger onEx) {
                        onEx.process(target, method.getName(), args, returnValue, eventScope, exception);
                    }
                }
            } else {
                for (EventTrigger trigger : triggers) {
                    if (!(trigger instanceof OnExceptionTrigger)) {
                        trigger.process(target, method.getName(), args, returnValue, eventScope);
                    }
                }
            }
        }

        if (exception != null) {
            throw exception;
        }

        return returnValue;
    }
}