package org.exploit.signalix.objects.util;

import org.exploit.signalix.annotations.OnCall;
import org.exploit.signalix.annotations.OnException;
import org.exploit.signalix.objects.trigger.EventTrigger;
import org.exploit.signalix.objects.trigger.OnCallTrigger;
import org.exploit.signalix.objects.trigger.OnExceptionTrigger;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class AnnotationTriggerParser {
    public static class ParsedTriggers {
        private final Map<Method, List<EventTrigger>> methodTriggers;

        ParsedTriggers(Map<Method, List<EventTrigger>> methodTriggers) {
            this.methodTriggers = methodTriggers;
        }


        public Map<Method, List<EventTrigger>> getMethodTriggers() {
            return methodTriggers;
        }
    }

    public static ParsedTriggers parseTriggers(Class<?> clazz) {
        Map<Method, List<EventTrigger>> methodTriggers = new HashMap<>();

        for (var method : clazz.getMethods()) {
            List<EventTrigger> triggers = new ArrayList<>();
            var onCall = method.getAnnotation(OnCall.class);
            if (onCall != null) {
                triggers.add(new OnCallTrigger(onCall.eventClass(), method));
            }

            var onException = method.getAnnotation(OnException.class);

            if (onException != null) {
                triggers.add(new OnExceptionTrigger(onException.eventClass()));
            }

            if (!triggers.isEmpty()) {
                methodTriggers.put(method, triggers);
            }
        }

        return new ParsedTriggers(methodTriggers);
    }
}