package org.exploit.signalix.objects.trigger;

import org.exploit.signalix.manager.EventScope;
import org.exploit.signalix.marker.Event;

public class OnExceptionTrigger implements EventTrigger {
    private final Class<? extends Event> eventClass;

    public OnExceptionTrigger(Class<? extends Event> eventClass) {
        this.eventClass = eventClass;
    }

    public void process(Object target, String methodName, Object[] args, Object returnValue, EventScope eventScope, Exception exception) {
        var e = createEventInstance(eventClass, target, exception);
        if (e != null) {
            eventScope.call(e);
        }
    }

    @Override
    public void process(Object target, String methodName, Object[] args, Object returnValue, EventScope eventScope) {
        throw new UnsupportedOperationException("Use process(target, methodName, args, returnValue, eventScope, exception)");
    }

    private Event createEventInstance(Class<? extends Event> eventClass, Object source, Exception exception) {
        try {
            var event = eventClass.getDeclaredConstructor().newInstance();
            copyFields(source, event);
            setExceptionFieldIfExists(event, exception);
            return event;
        } catch (Exception ignored) {}
        return null;
    }


    private Object getFieldValue(Object obj, String fieldName) {
        try {
            var f = obj.getClass().getDeclaredField(fieldName);
            f.setAccessible(true);
            return f.get(obj);
        } catch (Exception ignored) {}
        return null;
    }

    private void copyFields(Object source, Object dest) {
        var sFields = source.getClass().getDeclaredFields();
        var dFields = dest.getClass().getDeclaredFields();
        for (var df : dFields) {
            df.setAccessible(true);
            for (var sf : sFields) {
                sf.setAccessible(true);
                if (sf.getName().equals(df.getName()) && isAssignable(df.getType(), sf.getType())) {
                    try { df.set(dest, sf.get(source)); } catch (Exception ignored){}
                    break;
                }
            }
        }
    }

    private boolean isAssignable(Class<?> target, Class<?> source) {
        return target.isAssignableFrom(source);
    }

    private void setExceptionFieldIfExists(Event event, Exception exception) {
        try {
            var f = event.getClass().getDeclaredField("exception");
            if (Throwable.class.isAssignableFrom(f.getType())) {
                f.setAccessible(true);
                f.set(event, exception);
            }
        } catch (Exception ignored) {}
    }
}