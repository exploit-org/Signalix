package org.exploit.signalix.manager.loop;

import org.exploit.signalix.event.time.ExpirableEvent;
import org.exploit.signalix.event.time.TimedEvent;
import org.exploit.signalix.event.time.impl.EventExpired;
import org.exploit.signalix.marker.Event;

import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.locks.LockSupport;
import java.util.function.Consumer;

public class EventLoop implements AutoCloseable {
    private final PriorityQueue<TimedEvent> eventQueue = new PriorityQueue<>(Comparator.comparingLong(TimedEvent::scheduledNanoTime));
    private final ConcurrentLinkedQueue<Event> incomingEvents = new ConcurrentLinkedQueue<>();
    private final ConcurrentLinkedQueue<TimedEvent> incomingTimedEvents = new ConcurrentLinkedQueue<>();

    private final Thread eventLoopThread;
    private volatile boolean running = true;

    private final Consumer<Event> eventDispatcherCallback;

    public EventLoop(Consumer<Event> eventDispatcherCallback) {
        this.eventDispatcherCallback = eventDispatcherCallback;
        eventLoopThread = new Thread(this::eventLoop, "Signalix-EventLoop");
        eventLoopThread.start();
    }

    public void callEvent(Event event) {
        incomingEvents.offer(event);
        LockSupport.unpark(eventLoopThread);
    }

    public void scheduleEvent(TimedEvent event) {
        incomingTimedEvents.offer(event);
        LockSupport.unpark(eventLoopThread);
    }

    @Override
    public void close() {
        running = false;
        LockSupport.unpark(eventLoopThread);
        try {
            eventLoopThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    private void eventLoop() {
        while (running) {
            Event immediateEvent;
            while ((immediateEvent = incomingEvents.poll()) != null) {
                eventDispatcherCallback.accept(immediateEvent);
            }

            TimedEvent te;
            while ((te = incomingTimedEvents.poll()) != null) {
                eventQueue.offer(te);
            }

            var now = System.nanoTime();
            var nextEvent = eventQueue.peek();
            if (nextEvent == null) {
                LockSupport.park();
                continue;
            }

            var waitTime = nextEvent.scheduledNanoTime() - now;
            if (waitTime > 0) {
                LockSupport.parkNanos(waitTime);
                continue;
            }

            nextEvent = eventQueue.poll();
            if (nextEvent != null) {
                if (nextEvent instanceof ExpirableEvent expEvent && expEvent.isExpired(now)) {
                    var expiredNotification = new EventExpired(expEvent.getOriginal());
                    eventDispatcherCallback.accept(expiredNotification);
                } else {
                    eventDispatcherCallback.accept(nextEvent.getOriginal());
                }
            }
        }
    }
}
