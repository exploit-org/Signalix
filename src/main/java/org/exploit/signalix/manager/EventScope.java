package org.exploit.signalix.manager;

import org.exploit.signalix.event.EventObject;
import org.exploit.signalix.event.listener.ConsumerEventListener;
import org.exploit.signalix.event.listener.EventListener;
import org.exploit.signalix.event.listener.ReflectedEventListener;
import org.exploit.signalix.event.time.TimedEvent;
import org.exploit.signalix.exception.EventExecutionException;
import org.exploit.signalix.handler.Handler;
import org.exploit.signalix.manager.loop.EventLoop;
import org.exploit.signalix.marker.Event;
import org.exploit.signalix.marker.Listener;
import org.exploit.signalix.utils.EventConsumer;
import org.jetbrains.annotations.NotNull;

import java.io.Closeable;
import java.util.ArrayList;
import java.util.List;

/**
 * Class for calling and scheduling events.
 * After you created the listeners, you should register them
 * by calling registerListener(s) function.
 *
 * @see EventScope#call(Event)
 */

public class EventScope implements EventDispatcher, Closeable {
    protected final List<EventListener> listeners = new ArrayList<>();
    protected final EventLoop eventLoop;

    public EventScope() {
        this.eventLoop = new EventLoop(this::dispatchEvent);
    }

    @Override
    public <T extends Event> List<Handler<T>> getHandlers(@NotNull EventObject<T> event) {
        var handlers = new ArrayList<Handler<T>>();
        for (var listener : listeners) {
            handlers.addAll(listener.getEventHandlers(event));
        }
        handlers.sort(null);
        return handlers;
    }

    @Override
    public void registerListener(@NotNull Listener listener) {
        var reflectedListener = new ReflectedEventListener(listener);
        listeners.add(reflectedListener);
    }

    public void registerEventListener(EventListener listener) {
        listeners.add(listener);
    }

    public <T extends Event> void registerEvent(@NotNull Class<T> clazz, @NotNull EventConsumer<T> eventConsumer) {
        var consumerListener = new ConsumerEventListener<>(eventConsumer, clazz);
        listeners.add(consumerListener);
    }

    public <T extends Event> void unregisterEvent(@NotNull Class<T> clazz) {
        var removeList = listeners.stream()
                .filter(ConsumerEventListener.class::isInstance)
                .filter(e -> e.getName().equals(clazz.getName()))
                .toList();

        listeners.removeAll(removeList);
    }

    @Override
    public void removeListener(@NotNull Listener listener) {
        listeners.removeIf(e -> e.getName().equals(listener.getClass().getTypeName()));
    }

    public void removeListeners() {
        listeners.clear();
    }

    @Override
    public void call(Event event) {
        eventLoop.callEvent(event);
    }

    public void scheduleEvent(TimedEvent event) {
        eventLoop.scheduleEvent(event);
    }

    @Override
    public void close() {
        eventLoop.close();
        listeners.clear();
    }

    protected void dispatchEvent(Event event) {
        var eventObject = new EventObject<>(event);
        var handlers = getHandlers(eventObject);

        for (var handler : handlers) {
            if (eventObject.isCancelled() && !handler.isIgnoreCancelled()) {
                continue;
            }

            try {
                handler.execute(event);
            } catch (Exception e) {
                call(new EventExecutionException(e, event));
            }
        }
    }
}
