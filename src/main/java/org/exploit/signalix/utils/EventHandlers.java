package org.exploit.signalix.utils;

import org.exploit.signalix.annotations.EventHandler;
import org.exploit.signalix.marker.Event;
import org.exploit.signalix.marker.Listener;
import org.exploit.signalix.model.ExtractedHandlers;
import org.exploit.signalix.model.WrappedMethod;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

public final class EventHandlers {
    private EventHandlers() {}

    @SuppressWarnings("unchecked")
    public static ExtractedHandlers extract(Listener listener) {
        var eventHandlers = new HashMap<String, WrappedMethod[]>();
        var eventTypes = new ArrayList<Class<? extends Event>>();

        var clazz = listener.getClass();

        var methods = Arrays.stream(clazz.getDeclaredMethods())
                .filter(EventHandlers::isEventHandler)
                .map(WrappedMethod::new)
                .toList();

        for (var method : methods) {
            var args = method.getTypes();

            if (args.length == 0) continue;
            var eventType = args[0];

            var eventMethods = eventHandlers.get(eventType);

            if (eventMethods == null)
                eventMethods = new WrappedMethod[0];

            var eventClass = (Class<? extends Event>) method.getParameter(0);
            eventTypes.add(eventClass);

            var list = new ArrayList<>(Arrays.asList(eventMethods));
            list.add(method);

            eventHandlers.put(eventType, list.toArray(WrappedMethod[]::new));
        }

        return new ExtractedHandlers(eventHandlers, eventTypes);
    }

    private static boolean isEventHandler(Method m) {
        return m.isAnnotationPresent(EventHandler.class);
    }
}
