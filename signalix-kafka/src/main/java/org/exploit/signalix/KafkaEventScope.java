package org.exploit.signalix;

import org.exploit.signalix.annotation.KafkaEvent;
import org.exploit.signalix.annotation.KafkaEventListener;
import org.exploit.signalix.event.listener.ConsumerEventListener;
import org.exploit.signalix.event.listener.EventListener;
import org.exploit.signalix.event.listener.ReflectedEventListener;
import org.exploit.signalix.core.KafkaEventManager;
import org.exploit.signalix.model.KafkaEventMeta;
import org.exploit.signalix.utils.EventObjectMapper;
import org.exploit.signalix.manager.EventScope;
import org.exploit.signalix.marker.Event;
import org.exploit.signalix.marker.Listener;
import org.exploit.signalix.utils.EventConsumer;
import org.jetbrains.annotations.NotNull;

import java.util.List;
import java.util.Map;
import java.util.Properties;

import static org.exploit.signalix.utils.UtilityMethods.convertToProperties;
import static org.exploit.signalix.utils.UtilityMethods.extractAnnotation;

public class KafkaEventScope extends EventScope {
    private final KafkaEventManager kafkaEventManager;

    public KafkaEventScope(Properties properties) {
        this.kafkaEventManager = new KafkaEventManager(properties, this);
    }

    public KafkaEventScope(Map<String, String> properties) {
        this(convertToProperties(properties));
    }

    @Override
    public <T extends Event> void call(T event) {
        var eventClass = event.getClass();

        extractAnnotation(eventClass, KafkaEvent.class).ifPresentOrElse(
                meta -> kafkaEventManager.call(event, new KafkaEventMeta(meta)),
                () -> innerCall(event)
        );
    }

    public <T extends Event> void call(String topic, T event) {
        extractAnnotation(event.getClass(), KafkaEvent.class).ifPresentOrElse(
                annotation -> {
                    var meta = new KafkaEventMeta(topic, annotation.partition(), List.of(annotation.headers()));
                    call(meta, event);
                },
                () -> call(new KafkaEventMeta(topic), event)
        );
    }

    public <T extends Event> void call(KafkaEventMeta meta, T event) {
        kafkaEventManager.call(event, meta);
    }

    public <T extends Event> void innerCall(T event) {
        super.call(event);
    }

    @Override
    public void registerListener(@NotNull Listener listener) {
        var reflectedEventListener = new ReflectedEventListener(listener);

        registerEventListener(reflectedEventListener);

        var listenerClass = listener.getClass();

        extractAnnotation(listenerClass, KafkaEventListener.class).ifPresent(
                meta -> kafkaEventManager.registerKafkaListener(listenerClass, meta)
        );
    }

    @Override
    public <T extends Event> void registerEvent(@NotNull Class<T> clazz, @NotNull EventConsumer<T> eventConsumer) {
        var eventListener = new ConsumerEventListener<>(eventConsumer, clazz);

        registerEventListener(eventListener);

        extractAnnotation(clazz, KafkaEventListener.class).ifPresent(
                meta -> kafkaEventManager.registerKafkaListener(clazz, meta)
        );
    }

    @Override
    public void removeListener(@NotNull Listener listener) {
        super.removeListener(listener);

        var listenerName = listener.getClass().getName();
        kafkaEventManager.closeConsumer(listenerName);
    }

    @Override
    public <T extends Event> void unregisterEvent(@NotNull Class<T> clazz) {
        super.unregisterEvent(clazz);
        kafkaEventManager.closeConsumer(clazz.getName());
    }

    @Override
    public void registerEventListener(EventListener listener) {
        super.registerEventListener(listener);
        kafkaEventManager.getEventObjectMapper().registerEvents(listener);
    }

    @Override
    public void close() {
        super.close();
        kafkaEventManager.close();
    }

    public EventObjectMapper getObjectMapper() {
        return kafkaEventManager.getEventObjectMapper();
    }
}