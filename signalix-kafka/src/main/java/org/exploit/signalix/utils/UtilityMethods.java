package org.exploit.signalix.utils;

import org.apache.kafka.common.header.internals.RecordHeaders;
import org.exploit.signalix.model.KafkaEventMeta;

import java.lang.annotation.Annotation;
import java.util.*;

public final class UtilityMethods {
    private UtilityMethods() {}

    public static Map<String, String> convertToMap(List<String> array) {
        var map = new HashMap<String, String>();

        for (var value : array) {
            var split = value.split("=");

            if (split.length < 2) continue;

            map.put(split[0], split[1]);
        }

        return map;
    }

    public static Map<String, Object> convertToMap(Properties properties) {
        var entries = properties.entrySet();
        var map = new HashMap<String, Object>();

        for (var entry : entries)
            map.put(entry.getKey().toString(), entry.getValue());

        return map;
    }

    public static Map<String, String> convertToMap(String[] array) {
        return convertToMap(Arrays.stream(array).toList());
    }

    public static Properties convertToProperties(Map<String, String> map) {
        var properties = new Properties();
        properties.putAll(Objects.requireNonNull(map));

        return properties;
    }

    public static RecordHeaders extractHeaders(KafkaEventMeta event) {
        var headers = new RecordHeaders();

        convertToMap(Objects.requireNonNull(event.headers())).forEach(
                (key, value) -> headers.add(key, value.getBytes())
        );

        return headers;
    }

    public static <T extends Annotation> Optional<T> extractAnnotation(Class<?> clazz, Class<T> annotation) {
        if (clazz.isAnnotationPresent(annotation))
            return Optional.of(clazz.getAnnotation(annotation));

        return Optional.empty();
    }
}
